{"version":3,"sources":["node_modules/nearley/lib/nearley.js","node_modules/shuffle-array/index.js","node_modules/random-item/index.js","common.js","grammar.js","index.js"],"names":["module","exports","array","Array","isArray","TypeError","Math","floor","random","length","__importDefault","mod","__esModule","Object","defineProperty","value","shuffle_array_1","require","random_item_1","vocab","put","buy","own","word","gender","title","title_first","i","default","question","animal","kid","names","name","boy","girl","cat","eat","snake","eatBy","dog","kids","shift","push","took","NodePlusNode","l","r","strs","concat","NodeMinusNode","NodeMulNode","NodeDivNode","count","n","NodeNumber","id","x","common","grammar","Lexer","undefined","ParserRules","exp","parseInt","join","d","ParserStart","window","__importStar","result","k","hasOwnProperty","call","nearley","common_1","document","addEventListener","input","getElementById","story","q","onInput","p","parse","parser","Parser","Grammar","fromCompiled","feed","console","log","results","res","e","trim","innerHTML","innerText","focus"],"mappings":"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","file":"math2text.3ccb24da.js","sourceRoot":"..","sourcesContent":["(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        function stringifySymbolSequence (e) {\n            return e.literal ? JSON.stringify(e.literal) :\n                   e.type ? '%' + e.type : e.toString();\n        }\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(stringifySymbolSequence).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                                 + \" ● \"\n                                 + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n        return this.name + \" → \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n            // Having right set here will prevent the right state and its children\n            // form being garbage collected\n            state.right = undefined;\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n            var col = this.index - this.lastLineBreak;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += \"  \" + line + \"\\n\"\n            message += \"  \" + Array(col).join(\" \") + \"^\"\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n    }\n\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (token = lexer.next()) {\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.text !== undefined ? token.text : token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var err = new Error(this.reportError(token));\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.reportError = function(token) {\n        var lines = [];\n        var tokenDisplay = (token.type ? token.type + \" token: \" : \"\") + JSON.stringify(token.value !== undefined ? token.value : token);\n        lines.push(this.lexer.formatError(token, \"Syntax error\"));\n        lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\\n');\n        var lastColumnIndex = this.table.length - 2;\n        var lastColumn = this.table[lastColumnIndex];\n        var expectantStates = lastColumn.states\n            .filter(function(state) {\n                var nextSymbol = state.rule.symbols[state.dot];\n                return nextSymbol && typeof nextSymbol !== \"string\";\n            });\n\n        // Display a \"state stack\" for each expectant state\n        // - which shows you how this state came to be, step by step.\n        // If there is more than one derivation, we only display the first one.\n        var stateStacks = expectantStates\n            .map(function(state) {\n                return this.buildFirstStateStack(state, []);\n            }, this);\n        // Display each state that is expecting a terminal symbol next.\n        stateStacks.forEach(function(stateStack) {\n            var state = stateStack[0];\n            var nextSymbol = state.rule.symbols[state.dot];\n            var symbolDisplay = this.getSymbolDisplay(nextSymbol);\n            lines.push('A ' + symbolDisplay + ' based on:');\n            this.displayStateStack(stateStack, lines);\n        }, this);\n\n        lines.push(\"\");\n        return lines.join(\"\\n\");\n    };\n\n    Parser.prototype.displayStateStack = function(stateStack, lines) {\n        var lastDisplay;\n        var sameDisplayCount = 0;\n        for (var j = 0; j < stateStack.length; j++) {\n            var state = stateStack[j];\n            var display = state.rule.toString(state.dot);\n            if (display === lastDisplay) {\n                sameDisplayCount++;\n            } else {\n                if (sameDisplayCount > 0) {\n                    lines.push('    ⬆ ︎' + sameDisplayCount + ' more lines identical to this');\n                }\n                sameDisplayCount = 0;\n                lines.push('    ' + display);\n            }\n            lastDisplay = display;\n        }\n    };\n\n    Parser.prototype.getSymbolDisplay = function(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\" && symbol.literal) {\n            return JSON.stringify(symbol.literal);\n        } else if (type === \"object\" && symbol instanceof RegExp) {\n            return 'character matching ' + symbol;\n        } else if (type === \"object\" && symbol.type) {\n            return symbol.type + ' token';\n        } else {\n            throw new Error('Unknown symbol type: ' + symbol);\n        }\n    };\n\n    /*\n    Builds a the first state stack. You can think of a state stack as the call stack\n    of the recursive-descent parser which the Nearley parse algorithm simulates.\n    A state stack is represented as an array of state objects. Within a\n    state stack, the first item of the array will be the starting\n    state, with each successive item in the array going further back into history.\n\n    This function needs to be given a starting state and an empty array representing\n    the visited states, and it returns an single state stack.\n\n    */\n    Parser.prototype.buildFirstStateStack = function(state, visited) {\n        if (visited.indexOf(state) !== -1) {\n            // Found cycle, return null\n            // to eliminate this path from the results, because\n            // we don't know how to display it meaningfully\n            return null;\n        }\n        if (state.wantedBy.length === 0) {\n            return [state];\n        }\n        var prevState = state.wantedBy[0];\n        var childVisited = [state].concat(visited);\n        var childResult = this.buildFirstStateStack(prevState, childVisited);\n        if (childResult === null) {\n            return null;\n        }\n        return [state].concat(childResult);\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n","'use strict';\n\n/**\n * Randomize the order of the elements in a given array.\n * @param {Array} arr - The given array.\n * @param {Object} [options] - Optional configuration options.\n * @param {Boolean} [options.copy] - Sets if should return a shuffled copy of the given array. By default it's a falsy value.\n * @param {Function} [options.rng] - Specifies a custom random number generator.\n * @returns {Array}\n */\nfunction shuffle(arr, options) {\n\n  if (!Array.isArray(arr)) {\n    throw new Error('shuffle expect an array as parameter.');\n  }\n\n  options = options || {};\n\n  var collection = arr,\n      len = arr.length,\n      rng = options.rng || Math.random,\n      random,\n      temp;\n\n  if (options.copy === true) {\n    collection = arr.slice();\n  }\n\n  while (len) {\n    random = Math.floor(rng() * len);\n    len -= 1;\n    temp = collection[len];\n    collection[len] = collection[random];\n    collection[random] = temp;\n  }\n\n  return collection;\n};\n\n/**\n * Pick one or more random elements from the given array.\n * @param {Array} arr - The given array.\n * @param {Object} [options] - Optional configuration options.\n * @param {Number} [options.picks] - Specifies how many random elements you want to pick. By default it picks 1.\n * @param {Function} [options.rng] - Specifies a custom random number generator.\n * @returns {Object}\n */\nshuffle.pick = function(arr, options) {\n\n  if (!Array.isArray(arr)) {\n    throw new Error('shuffle.pick() expect an array as parameter.');\n  }\n\n  options = options || {};\n\n  var rng = options.rng || Math.random,\n      picks = options.picks || 1;\n\n  if (typeof picks === 'number' && picks !== 1) {\n    var len = arr.length,\n        collection = arr.slice(),\n        random = [],\n        index;\n\n    while (picks && len) {\n      index = Math.floor(rng() * len);\n      random.push(collection[index]);\n      collection.splice(index, 1);\n      len -= 1;\n      picks -= 1;\n    }\n\n    return random;\n  }\n\n  return arr[Math.floor(rng() * arr.length)];\n};\n\n/**\n * Expose\n */\nmodule.exports = shuffle;\n","'use strict';\n\nmodule.exports = array => {\n\tif (!Array.isArray(array)) {\n\t\tthrow new TypeError('Expected an array');\n\t}\n\n\treturn array[Math.floor(Math.random() * array.length)];\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shuffle_array_1 = __importDefault(require(\"shuffle-array\"));\nconst random_item_1 = __importDefault(require(\"random-item\"));\nconst vocab = {\n    put: ['שם', 'שמֵהַ'],\n    buy: ['קנה', 'קנתה'],\n    own: ['שברשותו', 'שברשותה']\n};\nfunction word(word, gender) {\n    const i = gender == 'boy' ? 0 : 1;\n    return word[i];\n}\nfunction title(gender) {\n    const title_first = [\n        ['לוֹחֵם', 'לוֹחֶמֶת'],\n        ['נָסִיךְ', 'נְסִיכַת'],\n        ['מֶלֶךְ', 'מַלְכַּת'],\n        ['גַּמָּד', 'פִּיַּת'],\n        ['שׁוֹדֵד', 'שׁוֹדֶדֶת'],\n        ['קוֹסֵם', 'מְכַשֶּׁפֶת']\n    ];\n    const title_second = [\n        'הַשּׁוֹקוֹלָד',\n        'הַחֲלוֹמוֹת',\n        'הָאוֹר',\n        'הַחֹשֶׁךְ',\n        'הַמַּמְתַּקִּים',\n        'הַיְּעָרוֹת',\n        'הַבִּצּוֹת',\n        'הַגְּבָעוֹת'\n    ];\n    const i = gender === 'boy' ? 0 : 1;\n    return `${random_item_1.default(title_first)[i]} ${random_item_1.default(title_second)}`;\n}\nexports.cat = {\n    name: 'חָתוּל',\n    names: 'חֲתוּלִים',\n    eat: () => { return exports.snake; },\n    eatBy: () => { return exports.dog; }\n};\nexports.dog = {\n    name: 'כֶּלֶב',\n    names: 'כְּלָבִים',\n    eat: () => { return exports.cat; },\n    eatBy: () => { return exports.snake; }\n};\nexports.snake = {\n    name: 'נָחָשׁ',\n    names: 'נְחָשִׁים',\n    eat: () => { return exports.dog; },\n    eatBy: () => { return exports.cat; }\n};\nfunction question(animal, kid) {\n    return `כַּמָּה ${animal.names} יֵשׁ לְ${kid.name}?`;\n}\nexports.question = question;\nfunction boy(name) {\n    return { name, gender: 'boy', title: title('boy') };\n}\nfunction girl(name) {\n    return { name, gender: 'girl', title: title('girl') };\n}\n// const kids = shuffle([\n//     boy('חבובו')\n//     , boy('יותם')\n//     , boy('אורי')\n//     , boy('יובל')\n//     , boy('אלעד')\n//     , boy('רוני')\n//     , boy('גיא')\n//     , girl('חבובה')\n//     , girl('נועה')\n//     , girl('דיאנה')\n//     , girl('שחר')\n//     , girl('שקד')\n//     , girl('נוגה בלי ו')\n//     , girl('מעיין')\n//     , girl('לוטם')\n//     , girl('עדי')\n//     , girl('דניאלה')\n// ])\nconst kids = shuffle_array_1.default([\n    boy('יִפְתַּח'),\n    boy('יוֹתָם'),\n    boy('יוֹאָב'),\n    boy('אוֹפִיר'),\n    boy('גִּלְעָד'),\n    boy('שַׁי'),\n    boy('אֵלִי'),\n    girl('יָעֵל'),\n    girl('עֵנָב'),\n    girl('מַעְיָן'),\n    girl('עֲנָת'),\n    girl('טַלְיָה'),\n    girl('אַיֶּלֶת'),\n    girl('פֶּסְיָה')\n]);\nfunction kid() {\n    const kid = kids.shift();\n    kids.push(kid);\n    return kid;\n}\nfunction took(gender) {\n    const boy = ['לָקַח', 'חָטַף', 'גָּנַב'];\n    const girl = ['לָקְחָה', 'גָּזְלָה', 'גָּנְבָה'];\n    return gender == 'boy'\n        ? random_item_1.default(boy)\n        : random_item_1.default(girl);\n}\nclass NodePlusNode {\n    constructor(l, r) {\n        this.kid = kid();\n        this.l = l;\n        this.r = r;\n    }\n    strs(animal) {\n        return this.l.strs(animal).concat(this.r.strs(animal)).concat([\n            `${this.kid.name}, ${this.kid.title}, ${took(this.kid.gender)} אֶת כָּל הַ${animal.names} שֶׁל ${this.l.kid.name} וְ${this.r.kid.name}.`\n        ]);\n    }\n}\nexports.NodePlusNode = NodePlusNode;\nclass NodeMinusNode {\n    constructor(l, r) {\n        this.kid = kid();\n        this.l = l;\n        this.r = r;\n    }\n    strs(animal) {\n        return this.l.strs(animal).concat(this.r.strs(animal.eatBy())).concat([\n            `כָּל אֶחָד מֵהַ${animal.eatBy().names} שֶׁל ${this.r.kid.name} אכל ${animal.name} אֶחָד שֶׁל ${this.l.kid.name}.`,\n            `${this.kid.name}, ${this.kid.title}, ${took(this.kid.gender)} אֶת כָּל הַ${animal.names} הַנּוֹתָרִים שֶׁל ${this.l.kid.name}.`\n        ]);\n    }\n}\nexports.NodeMinusNode = NodeMinusNode;\nclass NodeMulNode {\n    constructor(l, r) {\n        this.kid = kid();\n        this.l = l;\n        this.r = r;\n    }\n    strs(animal) {\n        return this.l.strs(animal).concat(this.r.strs(animal)).concat([\n            `לְכֹל ${animal.name} שֶׁל ${this.l.kid.name} נוֹלַד גּוּר אֶחָד מִכֹּל אֶחָד מֵהַ${animal.names} שֶׁל ${this.r.kid.name}.`,\n            `${this.kid.name}, ${this.kid.title}, ${took(this.kid.gender)} אֶת כָּל הַגּוּרִים שֶׁנּוֹלְדוּ.`\n        ]);\n    }\n}\nexports.NodeMulNode = NodeMulNode;\nclass NodeDivNode {\n    constructor(l, r) {\n        this.kid = kid();\n        this.l = l;\n        this.r = r;\n    }\n    strs(animal) {\n        return this.l.strs(animal).concat(this.r.strs(animal)).concat([\n            `${this.r.kid.name} ${word(vocab.buy, this.r.kid.gender)} כְּלוּב אֶחָד לְכֹל אֶחָד מֵהַ${animal.names} ${word(vocab.own, this.r.kid.gender)}.`,\n            `${this.l.kid.name} ${word(vocab.put, this.l.kid.gender)} אֶת הַ${animal.names} ${word(vocab.own, this.l.kid.gender)} בַּכְּלוּבִים שֶׁל ${this.r.kid.name}, מִסְפָּר זֵהֶה שֶׁל ${animal.names} בְּכָל כְּלוּב.`,\n            `${this.kid.name}, ${this.kid.title}, ${took(this.kid.gender)} אֶת כָּל הַ${animal.names} מֵאֶחָד הַכְּלוּבִים.`\n        ]);\n    }\n}\nexports.NodeDivNode = NodeDivNode;\nfunction count(n, animal) {\n    return n == 1\n        ? `${animal.name} אֶחָד`\n        : `${n} ${animal.names}`;\n}\nclass NodeNumber {\n    constructor(n) {\n        this.kid = kid();\n        this.n = n;\n    }\n    strs(animal) {\n        return [\n            `לְ${this.kid.name}, ${this.kid.title}, יֵשׁ ${count(this.n, animal)}.`\n        ];\n    }\n}\nexports.NodeNumber = NodeNumber;\n","// Generated automatically by nearley, version 2.19.2\n// http://github.com/Hardmath123/nearley\n(function () {\nfunction id(x) { return x[0]; }\n\n    const common = require('./common')\nvar grammar = {\n    Lexer: undefined,\n    ParserRules: [\n    {\"name\": \"exp\", \"symbols\": [\"exp\", \"_\", {\"literal\":\"+\"}, \"_\", \"term\"], \"postprocess\": ([l, $2, op, $4, r]) =>  new common.NodePlusNode(l, r)},\n    {\"name\": \"exp\", \"symbols\": [\"exp\", \"_\", {\"literal\":\"-\"}, \"_\", \"term\"], \"postprocess\": ([l, $2, op, $4, r]) =>  new common.NodeMinusNode(l, r)},\n    {\"name\": \"exp\", \"symbols\": [\"term\"], \"postprocess\": id},\n    {\"name\": \"term\", \"symbols\": [\"term\", \"_\", {\"literal\":\"*\"}, \"_\", \"factor\"], \"postprocess\": ([l, $2, op, $4, r]) => new common.NodeMulNode(l, r)},\n    {\"name\": \"term\", \"symbols\": [\"term\", \"_\", {\"literal\":\"/\"}, \"_\", \"factor\"], \"postprocess\": ([l, $2, op, $4, r]) => new common.NodeDivNode(l, r)},\n    {\"name\": \"term\", \"symbols\": [\"factor\"], \"postprocess\": id},\n    {\"name\": \"factor\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"exp\", \"_\", {\"literal\":\")\"}], \"postprocess\": ([lp, $2, exp, $4, rp]) => exp},\n    {\"name\": \"factor\", \"symbols\": [\"number\"], \"postprocess\": ([n]) => new common.NodeNumber(parseInt(n.join('')))},\n    {\"name\": \"number$ebnf$1\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"number$ebnf$1\", \"symbols\": [\"number$ebnf$1\", /[0-9]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"number\", \"symbols\": [\"number$ebnf$1\"], \"postprocess\": id},\n    {\"name\": \"_$ebnf$1\", \"symbols\": []},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", /[ \\t]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"]}\n]\n  , ParserStart: \"exp\"\n}\nif (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {\n   module.exports = grammar;\n} else {\n   window.grammar = grammar;\n}\n})();\n","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst nearley = __importStar(require(\"nearley\"));\nconst common_1 = require(\"./common\");\ndocument.addEventListener('DOMContentLoaded', () => {\n    const grammar = require(\"./grammar.js\");\n    function parse(exp) {\n        try {\n            const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));\n            parser.feed(exp);\n            console.log(parser.results);\n            const res = parser.results[0];\n            return {\n                story: res.strs(common_1.cat),\n                question: common_1.question(common_1.cat, res.kid)\n            };\n        }\n        catch (e) {\n            throw e;\n        }\n    }\n    const input = document.getElementById('input');\n    const story = document.getElementById('story');\n    const q = document.getElementById('question');\n    function onInput() {\n        try {\n            const p = parse(input.value.trim());\n            story.innerHTML = p.story.join(' ');\n            q.innerText = p.question;\n            console.log(q);\n        }\n        catch (e) {\n            console.log(e);\n            story.innerText = `Can't understand ${input.value}`;\n            q.innerText = '¯\\_(ツ)_/¯';\n        }\n    }\n    input.addEventListener('input', onInput);\n    input.focus();\n    input.value = '1 + 2';\n    onInput();\n});\n"]}